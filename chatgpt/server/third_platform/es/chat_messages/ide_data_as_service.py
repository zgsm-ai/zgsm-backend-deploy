#!/usr/bin/env python
# -*- coding: utf-8 -*-
from datetime import datetime
import pytz
from common.utils.util import code_get_line_and_language
from third_platform.es.base_es import BaseESService

class UserBehaviorAction:
    # Four types of interaction behaviors for IDE users, can be further expanded in the future
    user_behavior = ["copy", 'accept', 'diff', 'ctrlc']
    behavior_keys = {
        "copy": "user_copy",
        "accept": "user_accept",
        "diff": "user_diff",
        "ctrlc": "user_ctrlc"
    }

class PlugInESService(BaseESService):
    """Operation record es"""
    def __init__(self):
        super(PlugInESService, self).__init__()
        self.index = "ide_data"

    def insert_data(self, data):
        """
        Insert request data, follow different logic based on whether conversation_id exists
        :param data: Interface request parameter information
        """
        try:
            rid = data.get("conversation_id", "")
            # Calculate the total number of lines of code generated by the large model
            data["code_total_lines"], code_languages = code_get_line_and_language(data.get("response_content", ""))
            # Distinguish between shortcut command and smart Q&A
            if data.get("request_mode", "http") == "websocket":
                data["language"] = code_languages
            if self.es.exists(index=self.index, id=rid):
                # Session ID exists, perform data merging
                self.merge_data(rid, update_data=data)
            else:
                # If it doesn't exist, perform insert logic
                obj_dict = {
                    "username": data.get("username", ''),
                    "id": rid,
                    "model": data.get("agent_name", "").split("|")[-1] or "",
                    "action": data.get("action", ""),
                    "code": data.get("code", ""),
                    "query": data.get("prompt", ""),
                    "agent_name": data.get("agent_name", ""),
                    "code_total_lines": data["code_total_lines"],
                    "accept_num": data.get('accept_num', 0),
                    "language": data.get("language", ""),
                    "feedbacks": data.get("feedbacks", ""),
                    "path": data.get("path", ""),
                    "User-Agent": data.get("user_agent", ""),
                    "host": data.get("host", ""),
                    "response_content": data.get("response_content", ""),
                    "total_tokens": data.get("total_tokens", 0),
                    "created_at": self.process_time_format(data.get("created_at", "")),
                    "finish_at": self.process_time_format(data.get("finish_at", "")),
                    "ide": data.get("ide", ""),
                    "ide_version": data.get('ide_version', ''),
                    "ide_real_version": data.get('ide_real_version', ''),
                    "callType": data.get("callType", ""),
                    "request_nums": 1,  # When adding a new session, the default number of requests is 1
                    "user_copy": 0,
                    "user_diff": 0,
                    "user_accept": 0,
                    "user_ctrlc": 0
                }
                # Add an extra_kwargs field in dict format, all parameters are saved, and future new fields can be placed here.
                if 'extra_kwargs' in data.keys():
                    for key, value in data['extra_kwargs'].items():
                        try:
                            # There may be ISO format strings, try to parse the string into a datetime object
                            value = datetime.fromisoformat(value)
                        except Exception:
                            # If parsing fails, store in the original format
                            pass
                        obj_dict[key] = value
                self.insert(obj_dict, id=rid)
        except Exception as err:
            self.logger.error(f"Failed to insert ide_data into es, error log: {str(err)}")

    def process_time_format(self, timestamp):
        if timestamp:
            utc_time = datetime.utcfromtimestamp(timestamp)
            # Define Asia/Shanghai timezone
            shanghai_tz = pytz.timezone('Asia/Shanghai')
            # Convert UTC time to Asia/Shanghai time
            return utc_time.replace(tzinfo=pytz.utc).astimezone(shanghai_tz)
        else:
            return datetime.now(pytz.timezone('Asia/Shanghai'))

    def update_key_value(self, rid, key: str, value: str) -> dict:
        """
        Update user like data on the es platform
        rid: Corresponding to the id on the es platform,
        key: Corresponding key on the es platform
        value: Corresponding value on the es platform
        """
        result = {}
        if self.es.exists(index=self.index, id=rid):
            res = self.update_by_id(id=rid, update_data={f"{key}": value})
            if res.get("_shards", {}).get("successful") == 1:
                result = {"es_status": "The es platform is updated successfully!"}
            else:
                result = {"es_status": "Failed,update data is consistent with es data, no need to update!"}
        else:
            result = {"es_status": f"Update failed, the _id:{rid} does not exist!"}
        return result

    def get_es_data(self, rid):
        if self.es.exists(index=self.index, id=rid):
            return self.get(rid)
        else:
            return False

    def merge_data(self, rid: str, update_data: dict):
        """
        When inserting data, when the current session id already exists, follow the update append logic
        rid: id, unique id
        update_data: Data to be updated
        """
        try:
            # First get the existing data
            es_data = self.get_es_data(rid)
            # Data to be updated
            es_update_data = {
                # Each time a user makes a request, the count is incremented by 1
                "request_nums": es_data.get("request_nums", 1) + 1,
                "code": es_data.get("code", "") + "---" + update_data.get("code", ""),
                "query": es_data.get("query", "") + "\n" + update_data.get("prompt", ""),
                "code_total_lines": es_data["code_total_lines"] + update_data["code_total_lines"],
                "response_content": es_data.get("response_content", "") + "\n" + update_data.get("response_content",
                                                                                                 ""),
                "total_tokens": es_data.get("total_tokens", 0) + update_data.get("total_tokens", 0),
                "finish_at": self.process_time_format(update_data.get("finish_at", ""))
            }
            res = self.update_by_id(id=rid, update_data=es_update_data)
            if res.get("_shards", {}).get("successful") == 1:
                self.logger.info(f"_id:{rid} updated successfully!")
            else:
                self.logger.error("Update data failed!")
        except Exception as err:
            self.logger.error(f"Failed to update ide_data in es, error log: {str(err)}")

    def user_evaluate(self, name: str, rid: str, **fields):
        """
        User like processing
        action: The event corresponding to each agent
        rid: The id corresponding to the es platform
        """
        status = 200
        # Update fields on the es platform
        es_result = self.update_key_value(rid, 'feedbacks', fields.get('rating', ''))
        es_updata = self.get_es_data(rid)
        # Make user likes valid for this session
        if es_updata and fields.get("rating", "") == "like" and es_updata.get("accept_num", 0) == 0:
            self.update_key_value(rid, 'accept_num', 1)
        return es_result, status

    def user_behavior(self, rid: str, accept_num: int, behavior: str) -> dict:
        """
        Process user acceptance results, record every interaction behavior of the user
        Note: One session may have multiple requests, and multiple requests may include multiple interactions
        rid: The id recorded by the es platform
        accept_num: Number of lines accepted by the user
        """
        try:
            es_data = self.get_es_data(rid)
            if es_data and behavior in UserBehaviorAction.user_behavior:
                user_behavior = UserBehaviorAction.behavior_keys.get(f"{behavior}")
                update_data = {
                    "accept_num": es_data["accept_num"] + accept_num,
                    f"{user_behavior}": es_data.get(user_behavior, 1) + 1
                }
                res = self.update_by_id(rid, update_data)
                if res.get("_shards", {}).get("successful") == 1:
                    return {"es_status": "Successful"}
                else:
                    self.logger.error(f"Failed to update ide_data in es, error log: {str(res)}")
                    return {"es_status": "Failed"}
        except Exception as err:
            self.logger.error(f"Failed to update ide_data in es, error log: {str(err)}")

ide_es_service = PlugInESService()
